#!/usr/bin/python

#############################
# Victoria
# by maxhaesslein, 2020-2022
# https://maxhaesslein.de
#############################
version = "1.1.0"


# this script gets started automatically on login via crontab.
# user 'crontab' -e and add:
# @reboot ~/victoria/victoria


import glob
import stat
import os
import re
import signal
import time
from sys import exit
import pygame
import pianohat
import drumhat

BANK_PIANO = os.path.join(os.path.dirname(__file__), "sounds/piano")
BANK_DRUMS = os.path.join(os.path.dirname(__file__), "sounds/drums2")

MOUNT_PATH = '/mnt/victoria_usb'
MOUNT_VOLUME = '/dev/sda1'
FILETYPES = ['*.wav', '*.WAV', '*.ogg', '*.OGG']
use_drive = False # gets set to true if the volume is mounted

volume_step = 1.0/13.0
global_volume = 10.0/13.0

running = True

print("Press CTRL+C to exit.")

NOTE_OFFSET = 3
samples_piano = []
files_piano = []
octave_piano = 0
octaves_piano = 0
instrument_button_down = False
shutdown_button_counter = 0


options = {
        'samplerate': 44100,
        'folder_piano': '/piano',
        'folder_drums': '/drums',
        'use_display': True
    }


display_content = "Hi!"


if options['use_display']:
    # init the display

    print( 'using display' )

    import subprocess
    from board import SCL, SDA
    import busio
    from PIL import Image, ImageDraw, ImageFont
    import adafruit_ssd1306

    i2c = busio.I2C(SCL, SDA)
    disp = adafruit_ssd1306.SSD1306_I2C(128, 32, i2c)
    disp.fill(0)
    disp.show()
    width = disp.width
    height = disp.height
    image = Image.new("1", (width, height))
    draw = ImageDraw.Draw(image)
    draw.rectangle((0, 0, width, height), outline=0, fill=0)
    padding = -2
    top = padding
    bottom = height - padding
    x = 0
    font = ImageFont.load_default()

    draw.rectangle((0, 0, width, height), outline=0, fill=0)
    draw.text((x, top), "VICTORIA", font=font, fill=255)
    draw.text((x, top + 8), "v."+str(version), font=font, fill=255)
    disp.image(image)
    disp.show()
    time.sleep(0.1)


def disk_exists(path):
    try:
            return stat.S_ISBLK(os.stat(path).st_mode)
    except:
            return False
# check if usb thumb drive exists
print( 'check if '+str(MOUNT_VOLUME)+' exists')
if( disk_exists(MOUNT_VOLUME) ):
    print('  yes')

    # try to mount
    #os.system( 'sudo mount -o ro '+str(MOUNT_VOLUME)+' '+str(MOUNT_PATH) )
    # NOTE: mounting some usb devices as readonly may not work, so we removed the read only flag:
    os.system( 'sudo mount '+str(MOUNT_VOLUME)+' '+str(MOUNT_PATH) )
    use_drive = True
    BANK_PIANO = str(MOUNT_PATH)+options['folder_piano']
    BANK_DRUMS = str(MOUNT_PATH)+options['folder_drums']

else:
    print('  no')

if use_drive and os.path.isfile(str(MOUNT_PATH)+'/config.txt'):
    import configparser
    configParser = configparser.RawConfigParser()
    configParser.read( str(MOUNT_PATH)+'/config.txt' )
    for option in options:
        if configParser.has_option('Victoria', option):
            options[option] = configParser.get('Victoria', option)
            if options[option] == 'False':
                options[option] = False
            if options[option] == 'True':
                options[option] = True
            if option == 'samplerate':
                options[option] = int(options[option])

print( 'options:', options )

pygame.mixer.pre_init(options['samplerate'], -16, 1, 512)
pygame.mixer.init()
pygame.mixer.set_num_channels(32)

def set_volume( direction ):
    global global_volume
    if direction > 0:
        global_volume += volume_step
    elif direction < 0:
        global_volume -= volume_step

    if global_volume >= 1:
        global_volume = 1.0
    elif global_volume <= 0:
        global_volume = 0.0

    max_led = int(round(global_volume * 13))
    for i in range(0, 13):
        pianohat.set_led(i, False)
    for i in range(0, max_led):
        pianohat.set_led(i, True)

    set_all_volume()

def set_all_volume():
    global display_content
    print("set volume to "+str(global_volume))
    display_content = "set volume to "+str(round(global_volume, 2))
    for sound in samples_piano:
        sound.set_volume( global_volume )
    for sound in samples_drums:
        sound.set_volume( global_volume )


def get_filename(path):
    filename = os.path.basename(path)
    return filename


def handle_note(channel, pressed):
    global display_content
    channel = channel + (12 * octave_piano)
    if len(samples_piano) > 13:
        channel += NOTE_OFFSET
    if channel < len(samples_piano) and pressed:
        print('Playing Sound: {}'.format(files_piano[channel]))
        display_content = "#{} / {}".format(channel,get_filename(files_piano[channel]))
        samples_piano[channel].play(loops=0)


def handle_instrument(channel, pressed):
    global instrument_button_down
    global display_content
    instrument_button_down = pressed

    pianohat.set_led(13, False)
    pianohat.set_led(14, False)
    pianohat.set_led(15, False)

    if pressed:
        pianohat.auto_leds(False)
        pianohat.set_led(channel, True)

        max_led = int(round(global_volume * 13))
        for i in range(0, 13):
            pianohat.set_led(i, False)
        for i in range(0, max_led):
            pianohat.set_led(i, True)

    else:
        pianohat.auto_leds(True)
        global shutdown_button_counter
        shutdown_button_counter = 0
        for i in range(0, 16):
            pianohat.set_led(i, False)


def handle_octave_up(channel, pressed):
    global display_content
    if instrument_button_down:
        pianohat.set_led(channel, pressed)
        if pressed:
            set_volume( +1 )
    else:
        global octave_piano
        if pressed and octave_piano < octaves_piano:
            octave_piano += 1
            print('piano set: {}'.format(octave_piano))
            display_content = "piano set: {}".format(octave_piano+1)


def handle_octave_down(channel, pressed):
    global display_content
    if instrument_button_down:
        pianohat.set_led(channel, pressed)
        if pressed:
            set_volume( -1 )
    else:
        global octave_piano
        if pressed and octave_piano > 0:
            octave_piano -= 1
            print('piano set: {}'.format(octave_piano))
            display_content = "piano set: {}".format(octave_piano+1)



# drums
def handle_drums_hit(event):
    global display_content
    # event.channel is a zero based channel index for each pad
    # event.pad is the pad number from 1 to 8

    if event.pad == 8 and instrument_button_down:
        global shutdown_button_counter

        shutdown_button_counter += 1

        if shutdown_button_counter > 0:
            pianohat.auto_leds(False)
            for i in range(0, 16):
                pianohat.set_led(i, True)
        if shutdown_button_counter > 1:
            drumhat.all_on()
            for i in range(0, 16):
                pianohat.set_led(i, False)
                time.sleep(0.02)
            drumhat.all_off()

            shutdown_action( False )
        return

    try:
        samples_drums[event.channel].play(loops=0)
        print("You hit pad {}, playing: {}".format(event.pad,files_drums[event.channel]))
        display_content = "Pad {} / {}".format(event.pad, get_filename(files_drums[event.channel]))
    except IndexError:
        print("Pad {} has no sound".format(event.pad))
        display_content = "Pad {} has no sound".format(event.pad)

def handle_drums_release():
    pass

def shutdown_action( skip_shutdown ):
    global running
    print( 'starting shut down ...')

    running = False
    time.sleep(0.4)

    if options['use_display']:
        draw.rectangle((0, 0, width, height), outline=0, fill=0)
        draw.text((0,0), "bye!", font=font, fill=255)
        disp.image(image)
        disp.show()
        time.sleep(0.5)

    print("mixer fadeout (1s)")
    pygame.mixer.fadeout(1000)
    time.sleep(1)
    pygame.mixer.quit()


    print("pianohat: set leds to off")
    pianohat.auto_leds(False)
    for i in range(0, 16):
        pianohat.set_led(i, False)

    print( "drumhat: set leds to off")
    drumhat.all_off()


    if options['use_display']:
        print("clear display")
        # clear display:
        draw.rectangle((0, 0, width, height), outline=0, fill=0)
        disp.image(image)
        disp.show()


    if use_drive:
        print( 'unmounting '+str(MOUNT_PATH) )
        time.sleep(500)
        os.system( 'sudo umount '+str(MOUNT_PATH) )

    if not skip_shutdown:
        print("shut down system ...")
        os.system('sudo shutdown now')

    print("end program. bye.")


files_piano = []
for filetype in FILETYPES:
    files_piano.extend(glob.glob(os.path.join(BANK_PIANO, filetype)))
files_piano.sort()
octaves_piano = len(files_piano) / 12
samples_piano = [pygame.mixer.Sound(sample) for sample in files_piano]
octave_piano = int(octaves_piano / 2)

files_drums = []
for filetype in FILETYPES:
    files_drums.extend(glob.glob(os.path.join(BANK_DRUMS, filetype)))
files_drums.sort()
samples_drums = [pygame.mixer.Sound(f) for f in files_drums]

pianohat.auto_leds(False)

for i in range(0, 16):
    pianohat.set_led(i, False)

# ready-animation
for i in range(0, 13):
    pianohat.set_led(i, True)
    time.sleep(0.05)
time.sleep(0.2)
for i in range(0, 16):
    pianohat.set_led(i, False)

pianohat.auto_leds(True)

set_all_volume()

drumhat.on_hit(drumhat.PADS, handle_drums_hit)
drumhat.on_release(drumhat.PADS, handle_drums_release)

pianohat.on_note(handle_note)
pianohat.on_octave_up(handle_octave_up)
pianohat.on_octave_down(handle_octave_down)
pianohat.on_instrument(handle_instrument)



def sigint_handler(signal_received, frame):
    print('SIGINT or CTRL-C detected. Exiting gracefully')
    shutdown_action( True )
    exit(0)

signal.signal(signal.SIGINT, sigint_handler) # capture ctrl+c


if options['use_display']:
    while running:
        draw.rectangle((0, 0, width, height), outline=0, fill=0)

        cmd = 'cut -f 1 -d " " /proc/loadavg'
        CPU = subprocess.check_output(cmd, shell=True).decode("utf-8")
        cmd = "free -m | awk 'NR==2{printf \"Mem: %s/%s MB  %.2f%%\", $3,$2,$3*100/$2 }'"
        MemUsage = subprocess.check_output(cmd, shell=True).decode("utf-8")

        draw.text((x, top), "CPU: " + CPU, font=font, fill=255)
        draw.text((x, top + 8), MemUsage, font=font, fill=255)
        draw.text((x, top + 24), display_content, font=font, fill=255)

        disp.image(image)
        disp.show()
        time.sleep(0.001)


signal.pause()
